<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>easy blog</title><link>https://easycodetime.github.io</link><description>easy blog</description><copyright>easy blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://easycodetime.github.io</link></image><lastBuildDate>Mon, 02 Feb 2026 09:34:26 +0000</lastBuildDate><managingEditor>easy blog</managingEditor><ttl>60</ttl><webMaster>easy blog</webMaster><item><title>EDR致盲 - 清除6大内核回调 </title><link>https://easycodetime.github.io/post/EDR-zhi-mang-%20-%20-qing-chu-6-da-nei-he-hui-diao-%20.html</link><description># EDR致盲 - 清除6大内核回调

## LIST_ENTRY 结构(注意,此结构出现频率极高!!!!!!!!!!!!)
```
Windows 内核的 LIST_ENTRY 结构定义如下：

typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY* Flink;  // 指向下一个节点
    struct _LIST_ENTRY* Blink;  // 指向上一个节点
} LIST_ENTRY, *PLIST_ENTRY;

内核中使用双向链表,内存布局大概如下
typedef struct test
{
    ...
    _LIST_ENTRY list;
    int a;
    int b;
    char c[10];
    ...
}
```

## ObRegisterCallbacks(下面调试机器为windows7 x64系统，屏蔽EDR 对其3环进程的保护)
```
#初始加载pdb
!sym noisy
.reload /f nt

x nt!PsProcessType
dt nt!_OBJECT_TYPE


```

### 1)定位PsProcessType 和PsThreadType全局内核变量地址
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250310153913832_9247.png?raw=true)

### 2)获取PsProcessType的具体值(上一步获取的是指针),定位CallbackList链表(此链表中保存的就是我们要清除的回调函数地址)
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250310155104983_32105.png?raw=true)

### 3)查看CallbackList链表中的数据,定位具体要删除的回调函数地址(图中有点错误，选中的不是链表首尾，是下一节点和上一节点)
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250310164313536_27035.png?raw=true)


## CmRegisterCallback(清除注册表通知回调)

### 1)定位CallbackListHead双向链表地址
```
uf nt!CmUnRegisterCallback
x nt!CallbackListHead
```
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250311104641992_1532.png?raw=true)

### 2)遍历CallbackListHead
```
!list -x 'dt nt!_LIST_ENTRY' nt!CallbackListHead

typedef struct _CMREG_CALLBACK {
    LIST_ENTRY List;
    ULONG Unknown1;
    ULONG Unknown2;
    LARGE_INTEGER Cookie;
    PVOID Unknown3;
    PEX_CALLBACK_FUNCTION Function;
} CMREG_CALLBACK, *PCMREG_CALLBACK;
```
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250311111240442_28837.png?raw=true)
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250311111428490_29548.png?raw=true)

### 3)致盲
```
dq nt!CallbackListHead
eq fffff800`040db9f0 fffff800`040db9f0

致盲原理 =&gt; 断链
    1.方法一 判断双向链表中每项,哪个是杀软,在摘除当前项
    2.方法二 摘除所有项,简单粗暴,当前是此方法
```
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250311113229771_21636.png?raw=true)

## PsSetCreateProcessNotifyRoutine  PsSetCreateThreadNotifyRoutine PsSetLoadImageNotifyRoutine
```
进程通知回调、线程通知回调、Image 加载通知回调 摘除
下面以 PsSetCreateProcessNotifyRoutine 举例,其它都是一样的结构
```

### 1)定位 PspCreateProcessNotifyRoutine 数组
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20250311165644788_12695.png?raw=true)

### 2）遍历数据,判断是否致盲
```
下图中未公开的结构体为EX_CALLBACK_ROUTINE_BLOCK ，它是没有记录。</description><guid isPermaLink="true">https://easycodetime.github.io/post/EDR-zhi-mang-%20-%20-qing-chu-6-da-nei-he-hui-diao-%20.html</guid><pubDate>Mon, 02 Feb 2026 09:34:00 +0000</pubDate></item><item><title>IP TCP UDP数据报头的相关记录</title><link>https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</link><description># IP TCP UDP数据报头的相关记录


## IP数据报头
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20230226214359608_2250.png?raw=true)
```c
typedef struct _IP_HEADER_V4_
{
	union
	{
		UINT8 versionAndHeaderLength;
		struct
		{
			UINT8 headerLength : 4;
			UINT8 version : 4;
		};
	};
	union
	{
		UINT8  typeOfService;
		UINT8  differentiatedServicesCodePoint;
		struct
		{
			UINT8 explicitCongestionNotification : 2;
			UINT8 typeOfService6bit : 6;
		};
	};
	UINT16 totalLength;
	UINT16 identification;
	union
	{
		UINT16 flagsAndFragmentOffset;
		struct
		{
			UINT16 fragmentOffset : 13;
			UINT16 flags : 3;
		};
	};
	UINT8  timeToLive;
	UINT8  protocol;
	UINT16 checksum;
	BYTE   pSourceAddress[sizeof(UINT32)];
	BYTE   pDestinationAddress[sizeof(UINT32)];
}IP_HEADER_V4, *PIP_HEADER_V4;
```
```c
IP报头的长度
    IP_HEADER_V4 pHeader;
    int nLength = pHeader.headerLength * 4;
```

## TCP数据报头
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20230226215501000_20824.png?raw=true)
```c
typedef struct _TCP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT32 sequenceNumber;
	UINT32 acknowledgementNumber;
	union
	{
		UINT8 dataOffsetReservedAndNS;
		struct
		{
			UINT8 nonceSum : 1;
			UINT8 reserved : 3;
			UINT8 dataOffset : 4;
		}dORNS;
	};
	union
	{
		UINT8 controlBits;
		struct
		{
			UINT8 FIN : 1;
			UINT8 SYN : 1;
			UINT8 RST : 1;
			UINT8 PSH : 1;
			UINT8 ACK : 1;
			UINT8 URG : 1;
			UINT8 ECE : 1;
			UINT8 CWR : 1;
		};
	};
	UINT16 window;
	UINT16 checksum;
	UINT16 urgentPointer;
}TCP_HEADER, *PTCP_HEADER;
```
```
TCP报头的长度
    TCP_HEADER pHeader;
    int nLength = pHeader.dORNS.dataOffset * 4;
```

## UDP数据报头
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20230226215856227_2865.png?raw=true)
```c
typedef struct _UDP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT16 length;
	UINT16 checksum;
}UDP_HEADER, *PUDP_HEADER;
```
```
UDP报头的长度 = 固定长度
```

## 网络字节序的相互转换

## checksum值的计算
```c
/定义一个结构体来存储伪ip头部
struct pseudo_header
{
    uint32_t source_address;
    uint32_t dest_address;
    uint8_t placeholder;
    uint8_t protocol;
    uint16_t tcp_length;
};

//定义一个函数来计算16位二进制字符串之和
unsigned short csum(unsigned short *ptr,int nbytes) 
{
    long sum;
    unsigned short oddbyte;
    short answer;

    sum=0;
    while(nbytes&gt;1) {
        sum+=*ptr++;
        nbytes-=2;
    }
    if(nbytes==1) {
        oddbyte=0;
        *((u_char*)&amp;oddbyte)=*(u_char*)ptr;
        sum+=oddbyte;
    }

    sum = (sum&gt;&gt;16)+(sum &amp; 0xffff);
    sum = sum + (sum&gt;&gt;16);
    answer=(short)~sum;

    return(answer);
}

//定义一个函数来计算tcp的checksum
unsigned short tcp_checksum(struct tcphdr *tcph , int len_tcp , struct sockaddr_in *src_addr , struct sockaddr_in *dest_addr)
{
  //创建一个伪ip头部对象，并填充相关信息
  struct pseudo_header psh; 
  psh.source_address = src_addr-&gt;sin_addr.s_addr; //源地址
  psh.dest_address = dest_addr-&gt;sin_addr.s_addr; //目标地址
  psh.placeholder = 0; //占位符，固定为0
  psh.protocol = IPPROTO_TCP; //协议类型，固定为TCP
  psh.tcp_length = htons(len_tcp); //TCP长度

  //创建一个缓冲区，用于存储伪ip头部和tcp头部
  int total_len = sizeof(struct pseudo_header) + len_tcp; 
  char *buf = malloc(total_len);

  //将伪ip头部和tcp头部复制到缓冲区中
  memcpy(buf , (char*) &amp;psh , sizeof (struct pseudo_header));
  memcpy(buf + sizeof(struct pseudo_header) , tcph , len_tcp);

  //调用csum函数计算缓冲区中所有二进制字符串之和的反码，即为tcp的checksum值
  unsigned short check_sum = csum( (unsigned short*) buf , total_len);

  free(buf);

  return check_sum;

}
```。</description><guid isPermaLink="true">https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</guid><pubDate>Mon, 02 Feb 2026 08:49:35 +0000</pubDate></item><item><title>IP TCP UDP数据报头的相关记录</title><link>https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</link><description># IP TCP UDP数据报头的相关记录


## IP数据报头
![](_v_images/20230226214359608_2250.png =500x)
```c
typedef struct _IP_HEADER_V4_
{
	union
	{
		UINT8 versionAndHeaderLength;
		struct
		{
			UINT8 headerLength : 4;
			UINT8 version : 4;
		};
	};
	union
	{
		UINT8  typeOfService;
		UINT8  differentiatedServicesCodePoint;
		struct
		{
			UINT8 explicitCongestionNotification : 2;
			UINT8 typeOfService6bit : 6;
		};
	};
	UINT16 totalLength;
	UINT16 identification;
	union
	{
		UINT16 flagsAndFragmentOffset;
		struct
		{
			UINT16 fragmentOffset : 13;
			UINT16 flags : 3;
		};
	};
	UINT8  timeToLive;
	UINT8  protocol;
	UINT16 checksum;
	BYTE   pSourceAddress[sizeof(UINT32)];
	BYTE   pDestinationAddress[sizeof(UINT32)];
}IP_HEADER_V4, *PIP_HEADER_V4;
```
```c
IP报头的长度
    IP_HEADER_V4 pHeader;
    int nLength = pHeader.headerLength * 4;
```

## TCP数据报头
![](_v_images/20230226215501000_20824.png =550x)
```c
typedef struct _TCP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT32 sequenceNumber;
	UINT32 acknowledgementNumber;
	union
	{
		UINT8 dataOffsetReservedAndNS;
		struct
		{
			UINT8 nonceSum : 1;
			UINT8 reserved : 3;
			UINT8 dataOffset : 4;
		}dORNS;
	};
	union
	{
		UINT8 controlBits;
		struct
		{
			UINT8 FIN : 1;
			UINT8 SYN : 1;
			UINT8 RST : 1;
			UINT8 PSH : 1;
			UINT8 ACK : 1;
			UINT8 URG : 1;
			UINT8 ECE : 1;
			UINT8 CWR : 1;
		};
	};
	UINT16 window;
	UINT16 checksum;
	UINT16 urgentPointer;
}TCP_HEADER, *PTCP_HEADER;
```
```
TCP报头的长度
    TCP_HEADER pHeader;
    int nLength = pHeader.dORNS.dataOffset * 4;
```

## UDP数据报头
![](_v_images/20230226215856227_2865.png  =400x)
```c
typedef struct _UDP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT16 length;
	UINT16 checksum;
}UDP_HEADER, *PUDP_HEADER;
```
```
UDP报头的长度 = 固定长度
```

## 网络字节序的相互转换

## checksum值的计算
```c
/定义一个结构体来存储伪ip头部
struct pseudo_header
{
    uint32_t source_address;
    uint32_t dest_address;
    uint8_t placeholder;
    uint8_t protocol;
    uint16_t tcp_length;
};

//定义一个函数来计算16位二进制字符串之和
unsigned short csum(unsigned short *ptr,int nbytes) 
{
    long sum;
    unsigned short oddbyte;
    short answer;

    sum=0;
    while(nbytes&gt;1) {
        sum+=*ptr++;
        nbytes-=2;
    }
    if(nbytes==1) {
        oddbyte=0;
        *((u_char*)&amp;oddbyte)=*(u_char*)ptr;
        sum+=oddbyte;
    }

    sum = (sum&gt;&gt;16)+(sum &amp; 0xffff);
    sum = sum + (sum&gt;&gt;16);
    answer=(short)~sum;

    return(answer);
}

//定义一个函数来计算tcp的checksum
unsigned short tcp_checksum(struct tcphdr *tcph , int len_tcp , struct sockaddr_in *src_addr , struct sockaddr_in *dest_addr)
{
  //创建一个伪ip头部对象，并填充相关信息
  struct pseudo_header psh; 
  psh.source_address = src_addr-&gt;sin_addr.s_addr; //源地址
  psh.dest_address = dest_addr-&gt;sin_addr.s_addr; //目标地址
  psh.placeholder = 0; //占位符，固定为0
  psh.protocol = IPPROTO_TCP; //协议类型，固定为TCP
  psh.tcp_length = htons(len_tcp); //TCP长度

  //创建一个缓冲区，用于存储伪ip头部和tcp头部
  int total_len = sizeof(struct pseudo_header) + len_tcp; 
  char *buf = malloc(total_len);

  //将伪ip头部和tcp头部复制到缓冲区中
  memcpy(buf , (char*) &amp;psh , sizeof (struct pseudo_header));
  memcpy(buf + sizeof(struct pseudo_header) , tcph , len_tcp);

  //调用csum函数计算缓冲区中所有二进制字符串之和的反码，即为tcp的checksum值
  unsigned short check_sum = csum( (unsigned short*) buf , total_len);

  free(buf);

  return check_sum;

}
```。</description><guid isPermaLink="true">https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</guid><pubDate>Mon, 02 Feb 2026 08:48:29 +0000</pubDate></item><item><title>IP TCP UDP数据报头的相关记录</title><link>https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</link><description># IP TCP UDP数据报头的相关记录


## IP数据报头
![](_v_images/20230226214359608_2250.png =500x)
```c
typedef struct _IP_HEADER_V4_
{
	union
	{
		UINT8 versionAndHeaderLength;
		struct
		{
			UINT8 headerLength : 4;
			UINT8 version : 4;
		};
	};
	union
	{
		UINT8  typeOfService;
		UINT8  differentiatedServicesCodePoint;
		struct
		{
			UINT8 explicitCongestionNotification : 2;
			UINT8 typeOfService6bit : 6;
		};
	};
	UINT16 totalLength;
	UINT16 identification;
	union
	{
		UINT16 flagsAndFragmentOffset;
		struct
		{
			UINT16 fragmentOffset : 13;
			UINT16 flags : 3;
		};
	};
	UINT8  timeToLive;
	UINT8  protocol;
	UINT16 checksum;
	BYTE   pSourceAddress[sizeof(UINT32)];
	BYTE   pDestinationAddress[sizeof(UINT32)];
}IP_HEADER_V4, *PIP_HEADER_V4;
```
```c
IP报头的长度
    IP_HEADER_V4 pHeader;
    int nLength = pHeader.headerLength * 4;
```

## TCP数据报头
![](_v_images/20230226215501000_20824.png =550x)
```c
typedef struct _TCP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT32 sequenceNumber;
	UINT32 acknowledgementNumber;
	union
	{
		UINT8 dataOffsetReservedAndNS;
		struct
		{
			UINT8 nonceSum : 1;
			UINT8 reserved : 3;
			UINT8 dataOffset : 4;
		}dORNS;
	};
	union
	{
		UINT8 controlBits;
		struct
		{
			UINT8 FIN : 1;
			UINT8 SYN : 1;
			UINT8 RST : 1;
			UINT8 PSH : 1;
			UINT8 ACK : 1;
			UINT8 URG : 1;
			UINT8 ECE : 1;
			UINT8 CWR : 1;
		};
	};
	UINT16 window;
	UINT16 checksum;
	UINT16 urgentPointer;
}TCP_HEADER, *PTCP_HEADER;
```
```
TCP报头的长度
    TCP_HEADER pHeader;
    int nLength = pHeader.dORNS.dataOffset * 4;
```

## UDP数据报头
![](_v_images/20230226215856227_2865.png  =400x)
```c
typedef struct _UDP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT16 length;
	UINT16 checksum;
}UDP_HEADER, *PUDP_HEADER;
```
```
UDP报头的长度 = 固定长度
```

## 网络字节序的相互转换

## checksum值的计算
```c
/定义一个结构体来存储伪ip头部
struct pseudo_header
{
    uint32_t source_address;
    uint32_t dest_address;
    uint8_t placeholder;
    uint8_t protocol;
    uint16_t tcp_length;
};

//定义一个函数来计算16位二进制字符串之和
unsigned short csum(unsigned short *ptr,int nbytes) 
{
    long sum;
    unsigned short oddbyte;
    short answer;

    sum=0;
    while(nbytes&gt;1) {
        sum+=*ptr++;
        nbytes-=2;
    }
    if(nbytes==1) {
        oddbyte=0;
        *((u_char*)&amp;oddbyte)=*(u_char*)ptr;
        sum+=oddbyte;
    }

    sum = (sum&gt;&gt;16)+(sum &amp; 0xffff);
    sum = sum + (sum&gt;&gt;16);
    answer=(short)~sum;

    return(answer);
}

//定义一个函数来计算tcp的checksum
unsigned short tcp_checksum(struct tcphdr *tcph , int len_tcp , struct sockaddr_in *src_addr , struct sockaddr_in *dest_addr)
{
  //创建一个伪ip头部对象，并填充相关信息
  struct pseudo_header psh; 
  psh.source_address = src_addr-&gt;sin_addr.s_addr; //源地址
  psh.dest_address = dest_addr-&gt;sin_addr.s_addr; //目标地址
  psh.placeholder = 0; //占位符，固定为0
  psh.protocol = IPPROTO_TCP; //协议类型，固定为TCP
  psh.tcp_length = htons(len_tcp); //TCP长度

  //创建一个缓冲区，用于存储伪ip头部和tcp头部
  int total_len = sizeof(struct pseudo_header) + len_tcp; 
  char *buf = malloc(total_len);

  //将伪ip头部和tcp头部复制到缓冲区中
  memcpy(buf , (char*) &amp;psh , sizeof (struct pseudo_header));
  memcpy(buf + sizeof(struct pseudo_header) , tcph , len_tcp);

  //调用csum函数计算缓冲区中所有二进制字符串之和的反码，即为tcp的checksum值
  unsigned short check_sum = csum( (unsigned short*) buf , total_len);

  free(buf);

  return check_sum;

}
```。</description><guid isPermaLink="true">https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</guid><pubDate>Mon, 02 Feb 2026 08:40:11 +0000</pubDate></item><item><title>IP TCP UDP数据报头的相关记录</title><link>https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</link><description># IP TCP UDP数据报头的相关记录


## IP数据报头
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20230226214359608_2250.png?raw=true)
```c
typedef struct _IP_HEADER_V4_
{
	union
	{
		UINT8 versionAndHeaderLength;
		struct
		{
			UINT8 headerLength : 4;
			UINT8 version : 4;
		};
	};
	union
	{
		UINT8  typeOfService;
		UINT8  differentiatedServicesCodePoint;
		struct
		{
			UINT8 explicitCongestionNotification : 2;
			UINT8 typeOfService6bit : 6;
		};
	};
	UINT16 totalLength;
	UINT16 identification;
	union
	{
		UINT16 flagsAndFragmentOffset;
		struct
		{
			UINT16 fragmentOffset : 13;
			UINT16 flags : 3;
		};
	};
	UINT8  timeToLive;
	UINT8  protocol;
	UINT16 checksum;
	BYTE   pSourceAddress[sizeof(UINT32)];
	BYTE   pDestinationAddress[sizeof(UINT32)];
}IP_HEADER_V4, *PIP_HEADER_V4;
```
```c
IP报头的长度
    IP_HEADER_V4 pHeader;
    int nLength = pHeader.headerLength * 4;
```

## TCP数据报头
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20230226215501000_20824.png?raw=true)
```c
typedef struct _TCP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT32 sequenceNumber;
	UINT32 acknowledgementNumber;
	union
	{
		UINT8 dataOffsetReservedAndNS;
		struct
		{
			UINT8 nonceSum : 1;
			UINT8 reserved : 3;
			UINT8 dataOffset : 4;
		}dORNS;
	};
	union
	{
		UINT8 controlBits;
		struct
		{
			UINT8 FIN : 1;
			UINT8 SYN : 1;
			UINT8 RST : 1;
			UINT8 PSH : 1;
			UINT8 ACK : 1;
			UINT8 URG : 1;
			UINT8 ECE : 1;
			UINT8 CWR : 1;
		};
	};
	UINT16 window;
	UINT16 checksum;
	UINT16 urgentPointer;
}TCP_HEADER, *PTCP_HEADER;
```
```
TCP报头的长度
    TCP_HEADER pHeader;
    int nLength = pHeader.dORNS.dataOffset * 4;
```

## UDP数据报头
![](https://github.com/easycodetime/easycodetime.github.io/blob/main/blog_images/20230226215856227_2865.png?raw=true)
```c
typedef struct _UDP_HEADER_
{
	UINT16 sourcePort;
	UINT16 destinationPort;
	UINT16 length;
	UINT16 checksum;
}UDP_HEADER, *PUDP_HEADER;
```
```
UDP报头的长度 = 固定长度
```

## 网络字节序的相互转换

## checksum值的计算
```c
/定义一个结构体来存储伪ip头部
struct pseudo_header
{
    uint32_t source_address;
    uint32_t dest_address;
    uint8_t placeholder;
    uint8_t protocol;
    uint16_t tcp_length;
};

//定义一个函数来计算16位二进制字符串之和
unsigned short csum(unsigned short *ptr,int nbytes) 
{
    long sum;
    unsigned short oddbyte;
    short answer;

    sum=0;
    while(nbytes&gt;1) {
        sum+=*ptr++;
        nbytes-=2;
    }
    if(nbytes==1) {
        oddbyte=0;
        *((u_char*)&amp;oddbyte)=*(u_char*)ptr;
        sum+=oddbyte;
    }

    sum = (sum&gt;&gt;16)+(sum &amp; 0xffff);
    sum = sum + (sum&gt;&gt;16);
    answer=(short)~sum;

    return(answer);
}

//定义一个函数来计算tcp的checksum
unsigned short tcp_checksum(struct tcphdr *tcph , int len_tcp , struct sockaddr_in *src_addr , struct sockaddr_in *dest_addr)
{
  //创建一个伪ip头部对象，并填充相关信息
  struct pseudo_header psh; 
  psh.source_address = src_addr-&gt;sin_addr.s_addr; //源地址
  psh.dest_address = dest_addr-&gt;sin_addr.s_addr; //目标地址
  psh.placeholder = 0; //占位符，固定为0
  psh.protocol = IPPROTO_TCP; //协议类型，固定为TCP
  psh.tcp_length = htons(len_tcp); //TCP长度

  //创建一个缓冲区，用于存储伪ip头部和tcp头部
  int total_len = sizeof(struct pseudo_header) + len_tcp; 
  char *buf = malloc(total_len);

  //将伪ip头部和tcp头部复制到缓冲区中
  memcpy(buf , (char*) &amp;psh , sizeof (struct pseudo_header));
  memcpy(buf + sizeof(struct pseudo_header) , tcph , len_tcp);

  //调用csum函数计算缓冲区中所有二进制字符串之和的反码，即为tcp的checksum值
  unsigned short check_sum = csum( (unsigned short*) buf , total_len);

  free(buf);

  return check_sum;

}
```。</description><guid isPermaLink="true">https://easycodetime.github.io/post/IP%20TCP%20UDP-shu-ju-bao-tou-de-xiang-guan-ji-lu.html</guid><pubDate>Mon, 02 Feb 2026 07:45:24 +0000</pubDate></item><item><title>funchook库安装</title><link>https://easycodetime.github.io/post/funchook-ku-an-zhuang.html</link><description>## 编译 funchook 静态库
`
mkdir build &amp;&amp; cd build
cmake .. -DBUILD_SHARED_LIBS=OFF -DCMAKE_POSITION_INDEPENDENT_CODE=ON
make
sudo make install

-DCMAKE_POSITION_INDEPENDENT_CODE=ON  它会让 libfunchook.a 内部的目标文件都加上 -fPIC，这样才能安全地被 .so 使用
`。</description><guid isPermaLink="true">https://easycodetime.github.io/post/funchook-ku-an-zhuang.html</guid><pubDate>Tue, 19 Aug 2025 08:58:42 +0000</pubDate></item><item><title>linux常用命令记录</title><link>https://easycodetime.github.io/post/linux-chang-yong-ming-ling-ji-lu.html</link><description>### 根据pid知道可执行文件路径
```readlink -f /proc/pid/exe```

### 遍历所有进程的可执行文件路径
```for pid in $(ls /proc | grep -E '^[0-9]+$'); do exe=$(readlink -f /proc/$pid/exe 2&gt;/dev/null) &amp;&amp; echo '$pid $exe'; done```

### find搜索
```
find / -type f -name '*.so' | grep -i 'log' | xargs -n1 -I{} sh -c 'strings '{}' | grep '搜索字符串' &amp;&amp; echo 'find in: {}' &amp;&amp; echo'
find / -type f -name '*.so' | grep -i 'log' | xargs -n1 -I{} sh -c 'readelf -s '{}' | grep '搜索字符串' &amp;&amp; echo 'find in: {}' &amp;&amp; echo'
```

### strace常用记录
```
strace -xx -f -o xxx.log -e trace=network,write,read -p pid     以16进制形式来记录
strace -s 2048 -f -o xxx.log -e trace=network,write,read -p pid  以字符串形式来记录
```

。</description><guid isPermaLink="true">https://easycodetime.github.io/post/linux-chang-yong-ming-ling-ji-lu.html</guid><pubDate>Tue, 29 Jul 2025 09:16:21 +0000</pubDate></item></channel></rss>